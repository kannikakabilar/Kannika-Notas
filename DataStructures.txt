Data Structures

Primitive DS       - Predefined way of storing data (ex: int, char, float, double)
Non-Primitive DS   - It can store any set of values and even objects

  Linear DS        - elements stored sequentially
  Non-Linear DS    - elements connect to more than 1 elements (ie: trees, graphs)

  Static DS        - fixed size (ie: Arrays) 
  Dynamic DS       - can increase size as elements get inserted (ie: Linked List)


Arrays   -   indexing = O(1) but everything else O(n)

Sample Array Qs

def sortedArrayToBST(nums: List[int]):
    if len(nums) == 0:
        return None

    root = len(nums)//2 
    tree = TreeNode(nums[root])

    tree.left = sortedArrayToBST(self, nums[:root])

    tree.right = sortedArrayToBST(self, nums[root+1:])
    
    return tree

def searchSortedArray(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1              
        
    while left <= right:                        
        middle = (right+left) // 2       
        if nums[middle] == target:              
            return middle
        if nums[middle] > target:               
            right = middle - 1
        else:                                   
            left = middle + 1
    return left

def reverseMerge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:

    last = m + n - 1

    while m > 0 and n > 0:  
        if nums1[m - 1] > nums2[n - 1]:    
            nums1[last] = nums1[m - 1]    
            m -= 1                        
        else:                             
            nums1[last] = nums2[n - 1]
            n -= 1
        last -= 1  # of the two conditions one will be true, & new last pointer will be defined

    while n > 0:
        nums1[last] = nums2[n - 1]
        n, last = n - 1, last - 1

def generatePascal(numRows: int) -> List[List[int]]:
    l = []
    for i in range(numRows):
        l.append([])
        for j in range(i+1):
            if i == 0 or i == 1:
                l[i].append(1)
            elif j == 0 or j == i:
                l[i].append(1)
            else:
                l[i].append(l[i-1][j-1] + l[i-1][j])
    return l

def stockProfit(prices: List[int]) -> int:

    if prices != []:
        min = prices[0]

    diff = 0
    for i in range(1, len(prices)):
        if prices[i] < min:
            min = prices[i]
        if diff < prices[i] - min:
            diff = prices[i] - min

    return diff

def singleNumber(nums: List[int]) -> int:
    res = 0
    for num in nums:
        res ^= num
    return res

def removeDuplicates(nums: List[int]) -> int:
    length = len(nums)
    if length == 1:    
        return 1

    else:
        j = 0                          # i and j double pointers
        i = 1
        count = 1                      
        
        for i in range(length):        
            if nums[i] != nums[j]:
                j += 1                 # j only increases if i reaches a distinct element
                nums[j] = nums[i]      
                count += 1             
        
        return count

def removeElement(nums: List[int], val: int) -> int:
    j = 0                        # Create 2 pointers i and j
    i = 0
    for j in range:              
        if nums[j] != val:       
            nums[i] = nums[j]    
            i += 1               
    return i

def moveZeroes(nums: List[int]) -> None:
    i = 0                        # Create 2 pointers i and j
    j = 0
    zero = 0  

    for j in range(len(nums)):   
        if nums[j] != 0:         
            nums[i] = nums[j]
            i += 1
        else:
            zero += 1

    for j in range(zero):       
        nums[len(nums)-(j+1)] = 0
        
    return nums

def maxSubArray(nums: List[int]) -> int:
    # Kadane's algorithm
    maxi=nums[0] 
    sums=0
    for i in range(len(nums)):
        sums+=nums[i]
        maxi=max(sums,maxi)

        if sums<0: 
            sums=0
    
    return maxi

def stockProfit(prices: List[int]) -> int:
    # Kadane's algorithm
    maxCur = 0
    maxSoFar = 0

    for i in range(1, len(prices)):
        maxCur += prices[i] - prices[i-1]
        maxCur = max(0, maxCur)
        maxSoFar = max(maxCur, maxSoFar)

    return maxSoFar

___________________________________________


Linked Lists   -   inserting = O(1) but everything else O(n)

Sample Linked List Qs


___________________________________________

Stacks   -   used for evaluating math expr and recursive function calls

Sample Stack Qs


___________________________________________

Hash Table

  Terms
    - Hash function: input is key-value and the output is memory address/slot# of where the element will be stored
    - Collision => chaining: when 2 elements are directed to the same slot use linked list or trees to store the element at that address
    - Open Addressing: store all values within the hash table
      - Linear Probing: if hash(x) % S is full => (hash(x) + 1) % S

  Initializing HashMap and HashSet in Java

    import java.util.HashMap;
    import java.util.HashSet;

    HashMap<String, String> capitalCities = new HashMap<String, String>();
    capitalCities.put("USA", "Washington DC");
    String USCapital = capitalCities.get("USA");  // "Washington DC"

    for (String i : capitalCities.keySet()) {
        System.out.println(i);  // Print keys
    }

    for (String i : capitalCities.values()) {
        System.out.println(i);  // Print values
    }

    HashSet<String> cars = new HashSet<String>();
    cars.add("McLaren");
    cars.contains("McLaren"); // Returns True


Sample HashMap/HashSet Qs


___________________________________________


Trees

Sample Tree Implementations


___________________________________________


Graphs

Terms
  - order of a graph = # of vertices in graph
  - size of a graph = # of edges of a graph
  - null graph = 0 edges in graph (but may have vertices)
  - complete graph = has edges with all combination of vertices
  - adjacency matrix = nxn matrix where matrix[i][j] indicates an edge/edge_weight between vertex i and j
  - adjacency list = key-value table where there's 1 key for each vertex and a list with vertices that the key vertex connects to

___________________________________________












